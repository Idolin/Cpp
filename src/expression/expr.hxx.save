#pragma once

#include "../other/hash.h"
#include "../debug/def_debug.h"

#include <math.h>
#include <memory>
#include <typeinfo>

using std::enable_if;
using std::is_base_of;
using std::make_shared;
using std::shared_ptr;

struct ExprTag
{
    virtual ~ExprTag() = default;
};

struct Expr : ExprTag, Hashable
{
    virtual bool operator==(const Expr &b) const = 0;

    virtual bool equals(const Self *) const = 0;

    bool operator==(const ExprAbst &b) const
    {
        if(typeid(b) == typeid(const Self))
            return equals(static_cast<const Self *>(&b));
        return false;
    }
};

template<class Self, class ExprT = ExprAbstract,
        typename enable_if<is_base_of<ExprAbstract, ExprT>::value>::type * = nullptr>
struct Expr : ExprT
{
    shared_ptr<ExprT> e;
};

template<class Self, class ExprT = ExprAbstract,
        typename enable_if<is_base_of<ExprAbstract, ExprT>::value>::type * = nullptr>
struct Unary : Expr
{
    shared_ptr<ExprT> f;

    Unary(ExprT *f) : f(shared_ptr<ExprT>(f))
    {}

    virtual ~Unary()
    {
        //delete f;
    }

    bool operator==(const ExprAbstract &b) const
    {
        if(typeid(b) == typeid(const Self))
            return (*f == *(static_cast<const Self *>(&b)->f));
        return false;
    }
};

template<class Self, bool associative = true, class ExprT = ExprAbstract,
        typename enable_if<is_base_of<ExprAbstract, ExprT>::value>::type * = nullptr>
struct Binary : ExprT
{
    shared_ptr<ExprT> l, r;

    Binary(ExprT *l, ExprT *r) : l(shared_ptr<ExprT>(l)), r(shared_ptr<ExprT>(r))
    {}

    virtual ~Binary()
    {}

    bool operator==(const ExprAbstract &b) const
    {
        if(typeid(b) == typeid(const Self))
        {
            const Self *b_cast = static_cast<const Self *>(&b);
            if((*l == *(b_cast->l)) && (*r == *(b_cast->r)))
                return true;
            return ((!associative) && (*l == *(b_cast->r)) && (*r == *(b_cast->l)));
        }
        return false;
    }
};
